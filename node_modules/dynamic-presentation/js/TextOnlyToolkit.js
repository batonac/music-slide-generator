/* globals */
import { PianoRollToolkit } from '../js/PianoRollToolkit.js?v=3.0.0';

export class TextOnlyToolkit extends PianoRollToolkit {
  getPageCount () {
    return this.pages.length;
  }

  getPageWithElement (id) {
    let pageIdx = this.pages.findIndex((page) => {
      return page.indexOf(id) !== -1;
    });
    return pageIdx;
  }

  renderToSVG (page) {
    let output = '';
    output += this.pages[page];
    return output;
  }

  _assignMeasuresToPages () {
    if (!this.textLines) {
      let initialTextLines = [[]];
      let i = 0;
      let lyricIdx = 0;
      this.data.measures.forEach((measure, measureNum) => {
        if ((measure.sectionBreak || measure.pageBreak) && measureNum > 1) {
          initialTextLines.push([]);
          for (let l = 0; l < lyricIdx; l++) {
            // Ensure that translation lines have the same number of lyrics as each other
            let translationLines = initialTextLines[i];
            translationLines.forEach((translationLine) => {
              if (!translationLine[l]) {
                translationLine.push(['', '']);
              }
            });
          }
          lyricIdx = 0;
          i++;
        }
        measure.notes.forEach((note) => {
          let hasLyric = false;
          note.lyrics.forEach((lyric, j) => {
            if (lyric) {
              if (!initialTextLines[i][j]) {
                initialTextLines[i][j] = [];
              }
              while (!initialTextLines[i][j][lyricIdx]) {
                // Ensure that translation lines have the same number of lyrics as each other
                initialTextLines[i][j].push(['', '']);
              }
              initialTextLines[i][j][lyricIdx] = [`${note.id}-${j}`, lyric];
              hasLyric = true;
            }
          });
          if (hasLyric) {
            lyricIdx++;
          }
        });
      });
      for (let l = 0; l < lyricIdx; l++) {
        // Ensure that translation lines have the same number of lyrics as each other
        let translationLines = initialTextLines[i];
        translationLines.forEach((translationLine) => {
          if (!translationLine[l]) {
            translationLine.push(['', '']);
          }
        });
      }
      this.textLines = [];
      // Break lines which are longer than 50 characters into approximately equal parts (without separating words)
      // TODO: Should this be dependent on page dimensions?
      let lineLimit = 50;
      for (let i = 0; i < initialTextLines.length; i++) {
        let initialTextLine = initialTextLines[i];
        let longestTranslationLength = 0;
        let longestTranslationIdx = 0;
        for (let j = 0; j < initialTextLine.length; j++) {
          let lyricLength = 0;
          let translationTextLine = initialTextLine[j];
          for (let k = 0; k < translationTextLine.length; k++) {
            let lyric = translationTextLine[k][1];
            if (lyric) {
              lyricLength += lyric.length;
            }
            if (lyricLength > longestTranslationLength) {
              longestTranslationLength = lyricLength;
              longestTranslationIdx = j;
            }
          }
        }
        let lyrics = initialTextLine[longestTranslationIdx];
        let start = 0;
        let end = lyrics ? lyrics.length : 0;
        if (longestTranslationLength > lineLimit) {
          let charLimit =
            longestTranslationLength /
            Math.ceil(longestTranslationLength / lineLimit);
          let charCount = 0;
          for (let j = 0; j < lyrics.length; j++) {
            let lyric = lyrics[j][1];
            charCount += lyric.length;
            if (
              charCount > charLimit &&
              lyric.substring(lyric.length - 1) === ' '
            ) {
              end = j + 1;
              let textLine = [];
              for (let k = 0; k < initialTextLine.length; k++) {
                let translationLine = initialTextLine[k];
                textLine.push(translationLine.slice(start, end));
              }
              this.textLines.push(textLine);
              start = end;
              end = lyrics.length;
              charCount = 0;
            }
          }
        }
        let textLine = [];
        for (let k = 0; k < initialTextLine.length; k++) {
          let translationLine = initialTextLine[k];
          textLine.push(translationLine.slice(start, end));
        }
        this.textLines.push(textLine);
      }
    }
    let totalLineCount = 0;
    for (let i = 0; i < this.textLines.length; i++) {
      totalLineCount += this.textLines[i].length;
    }
    // Number of "translation lines".
    let tLines = Math.max(1, this.textLines[0].length);
    // 50 height with a margin of 20 (that is shared).
    // Adding 10 so that a few lines wrapping won't mess everything up.
    // TODO: detect lines that wrap and account for them when distributing
    // lines across different slides.
    let tLineHeight = 80 + 10;
    // linesPerPage doesn't count translation lines.
    let linesPerPage = Math.floor(this.height / tLineHeight / tLines);
    // There needs to be at least 1 line per page so we aren't dividing by zero later.
    linesPerPage = linesPerPage > 0 ? linesPerPage : 1;

    // Make sure that we don't put more lines on a page than would fit
    let maxLinesPerPage = 7;
    linesPerPage = Math.min(maxLinesPerPage, linesPerPage * tLines);
    // Make sure that we don't put more lines on a page than we need to.
    let numPages = Math.ceil(totalLineCount / linesPerPage);
    linesPerPage = Math.ceil(totalLineCount / numPages);
    // Make sure we put a multiple of tLines on each page (so translations aren't separated)
    linesPerPage = Math.floor(linesPerPage / tLines) * tLines;
    // Recalculate numPages now that we've adjusted linesPerPage
    numPages = Math.ceil(totalLineCount / linesPerPage);
    let percentUnused = 30;
    let virtualLinesAboveAndBelow = (maxLinesPerPage - linesPerPage) / 2;
    let percentagePerLine = (100 - percentUnused) / maxLinesPerPage;
    let startingPercent =
      percentUnused / 2 + (virtualLinesAboveAndBelow + 0.5) * percentagePerLine;
    // TODO: evenly distribute the lines to the pages.
    // number of pages that have one less than the maximum number of linesPerPage.
    // let sadPages = numPages * linesPerPage - this.textLines.length;
    for (let i = 1; i <= numPages; i++) this.pages.push('');

    // Open each page's svg
    for (let i = 1; i <= numPages; i++) {
      this.pages[i] += `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${this.width}px" height="${this.height}px" version="1.1" overflow="visible">
          <desc></desc>
          <defs></defs>
          <style type="text/css"></style>
          <svg class="definition-scale" color="black">
            <g class="page-margin">
      `;
    }
    // Insert the svg contents line by line
    let totalLineIdx = 0;
    // For each set of line along with its associated translation lines...
    this.textLines.forEach((line, i) => {
      // Page index takes the title page into account
      let pageIdx = Math.floor(totalLineIdx / linesPerPage) + 1;
      if (totalLineIdx / linesPerPage === numPages - 1) {
        // If this is the final page, recalculate the starting percentage based on how many lines are left
        let linesLeft = totalLineCount - totalLineIdx;
        virtualLinesAboveAndBelow = (maxLinesPerPage - linesLeft) / 2;
        startingPercent =
          percentUnused / 2 +
          (virtualLinesAboveAndBelow + 0.5) * percentagePerLine;
      }
      // For each (translation) line...
      line.forEach((tline, k) => {
        if (tline) {
          let lineIdx = totalLineIdx % linesPerPage;
          let yPercent = startingPercent + lineIdx * percentagePerLine;
          let info = { italic: k + 1 > 1 };
          this.pages[pageIdx] +=
            `<text x="50%" y="${yPercent}%" font-size="42px" dominant-baseline="middle" text-anchor="middle" xml:space="preserve">` +
            tline.map(this._makeSyl, info).join('') +
            `</text>`;
        }
        totalLineIdx++;
      });
    });
    // Close each page's svg
    for (let i = 1; i <= numPages; i++) {
      this.pages[i] += `
            </g>
          </svg>
        </svg>
      `;
    }
  }

  _debug (message) {
    console.log(`TextOnlyToolkit: ${message}`);
  }

  _getLyric (lyric) {
    let text = super._getLyric(lyric);
    return text
      .replaceAll('â€¿', ' ')
      .replaceAll('\xa0', ' ')
      .replaceAll('-', '');
  }

  _makeSyl (word) {
    // Separate the spaces from words, so that they aren't highlighted
    let endsInSpace = word[1].slice(-1) === ' ';
    return (
      `<tspan id="${word[0]}"` +
      (this.italic ? ' font-style="italic"' : '') +
      `>${word[1].trim()}</tspan>` +
      (endsInSpace ? ' ' : '')
    );
  }
}
