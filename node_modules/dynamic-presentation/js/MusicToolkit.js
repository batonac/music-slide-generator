/* globals DOMParser, verovio */
export class MusicToolkit extends verovio.toolkit {
  constructor () {
    super();
    this.scale = 60;
    this.width = 1024;
    this.height = 768;
    this.options = {};
    this.adjustPageHeight = false;
    this._configValues();
    this.musicData = null;
    this.numVerses = 1;
    this.numStaves = 2;
    this.firstOptionsSet = true;
  }

  setMusicData (musicData) {
    this.musicData = musicData;
  }

  getPageCount () {
    // All verovio pages plus the title page
    return super.getPageCount() + 1;
  }

  getElementsAtTime (time) {
    let eat = super.getElementsAtTime(time);
    if (typeof eat.notes !== 'undefined' && eat.notes.length) {
      // All getPageWithElement() don't account for the title page, so add one
      let page = this.getPageWithElement(eat.notes[0]) + 1;
      return {
        notes: eat.notes,
        page: page
      };
    }
    return {};
  }

  renderToMIDI () {
    if (this.musicData) {
      // eslint-disable-next-line new-cap
      let newVerovio = new verovio.toolkit();
      newVerovio.setOptions(this.getOptions());
      newVerovio.loadData(this.musicData);
      return newVerovio.renderToMIDI();
    } else {
      return this.renderToMIDI();
    }
  }

  renderToSVG (page) {
    if (page === 0) {
      // The title page doesn't come from verovio
      return this.pages[page];
    }
    return super.renderToSVG(page);
  }

  setOptions (options) {
    if (this.firstOptionsSet) {
      this.firstOptionsSet = false;
    } else {
      // For some reason setting this option more than once causes an error
      delete options.svgAdditionalAttribute;
    }
    this.options = options;
    super.setOptions(options);
    if (options.scale) {
      this.scale = options.scale;
    }
    // For some reason, pageWidth and pageHeight options are not the actual pixel values...
    if (options.pageWidth) {
      this.width = (options.pageWidth / 100) * this.scale;
    }
    if (options.pageHeight) {
      this.height = (options.pageHeight / 100) * this.scale;
    }
    if (options.adjustPageHeight) {
      this.adjustPageHeight = options.adjustPageHeight;
    }
    if (options.breaks) {
      if (options.breaks === 'line' || options.breaks === 'encoded') {
        // Using section breaks will automatically change the xScale.
        this.useSectionBreaks = true;
      }
    }
    // options.noHeader is deprecated in verovio.
    if (options.noHeader || options.header === 'none') {
      this.noHeader = true;
    }
    this._configValues();
  }

  loadData (data) {
    super.loadData(data);
    data = super.getMEI();
    let parser = new DOMParser();
    let doc = parser.parseFromString(data, 'text/xml');
    return this.loadDataFromDoc(doc);
  }

  loadDataFromDoc (doc) {
    this.doc = doc;
    this.lowNote = Infinity;
    this.highNote = -Infinity;
    this.data = {};
    this.chordSymbols = false;
    this.xmlType =
      this.doc.firstElementChild.tagName === 'mei' ? 'mei' : 'musicxml';
    let title = this.doc.querySelector(
      'work work-title, movement-title, titleStmt title:not([type="subordinate"])'
    );
    this.data.title = title ? title.innerHTML : '';
    let subtitle = this.doc.querySelector(
      'work work-number, movement-number, titleStmt title[type="subordinate"]'
    );
    this.data.subtitle = subtitle ? subtitle.innerHTML : '';
    let composer = this.doc.querySelector(
      'identification creator[type=composer], titleStmt respStmt persName[role=composer]'
    );
    this.data.composer = composer ? composer.innerHTML : '';
    let lyricist = this.doc.querySelector(
      'identification creator[type=lyricist], titleStmt respStmt persName[role=lyricist]'
    );
    this.data.lyricist = lyricist ? lyricist.innerHTML : '';
    // Try to find explicit footer credits,
    let footer = this.doc.querySelector(
      'score-partwise credit credit-words[default-y="0"], pgFoot'
    );
    // Otherwise, fallback on semantic elements usually placed at the bottom.
    footer = (footer ? footer.innerHTML : false)
      ? footer
      : this.doc.querySelector(
        'identification rights, pubStmt availability distributor'
      );
    this.data.footer = footer ? footer.textContent.trim() : '';
    this.data.measures = [];
    this.data.voices = {};
    this.doc.querySelectorAll('part, section').forEach((part) => {
      let measures = part.querySelectorAll('measure');
      for (let i = 0; i < measures.length; i++) {
        measures[i].setAttribute('number', i + 1);
      }
    });
    this.doc.querySelectorAll('measure').forEach((measure) => {
      const measureNumber =
        measure.getAttribute('number') || measure.getAttribute('n');
      this.data.measures[measureNumber] = {
        notes: [],
        chordSymbols: [],
        duration: 0,
        pageBreak: false,
        sectionBreak: false
      };
    });
    this.numVerses = 1;
    this.numStaves = this.doc.querySelectorAll(
      this.xmlType === 'musicxml' ? 'score-part' : 'staffDef'
    ).length;
    this.doc.querySelectorAll('measure').forEach((measure) => {
      const measureNumber =
        measure.getAttribute('number') || measure.getAttribute('n');

      let previousBreak = measure.previousElementSibling;
      if (this.xmlType === 'mei') {
        while (
          previousBreak &&
          ['sb', 'pb', 'measure'].indexOf(previousBreak.localName) === -1
        ) {
          previousBreak = previousBreak.previousElementSibling;
        }
      }
      if (
        measure.querySelector('print[new-system="yes"]') ||
        (previousBreak && previousBreak.localName === 'sb')
      ) {
        this.data.measures[measureNumber].sectionBreak = true;
      }
      if (
        measure.querySelector('print[new-page="yes"]') ||
        (previousBreak && previousBreak.localName === 'pb')
      ) {
        this.data.measures[measureNumber].sectionBreak = true;
        this.data.measures[measureNumber].pageBreak = true;
      }

      // Go through the notes and rests sequentially so we can get their offsets straight.
      let notes;
      if (this.xmlType === 'mei') {
        notes = measure.querySelectorAll(
          // Take chords, rests, spaces, and notes-not-contained-by-chords.
          'layer chord, layer rest, layer space, ' +
            // MEI notes can be nested inside many elements.
            // We just want the ones where you can't note.closest('chord').
            'layer>note, layer>*:not(chord)>note, layer>*:not(chord)>*:not(chord)>note'
        );
      } else {
        // TODO: Support parsing <backup><duration> in MusicXML.
        notes = measure.querySelectorAll('note, rest');
      }
      let offset = {};
      let previousDuration = 0;
      for (let i = 0; i < notes.length; i++) {
        let part = measure.closest('part');
        const partID = part
          ? part.getAttribute('id')
          : notes[i].closest('staff').getAttribute('n');

        let duration;
        if (this.xmlType === 'mei') {
          // TODO: Also select from note if this is a chord.
          duration = notes[i].getAttribute('dur.ppq');
        } else {
          duration = notes[i].querySelector('duration')
            ? notes[i].querySelector('duration').innerHTML
            : 0;
        }
        duration = parseInt(duration);
        const voice = notes[i].querySelector('voice')
          ? notes[i].querySelector('voice').innerHTML
          : notes[i].closest('layer')
            ? notes[i].closest('layer').getAttribute('n')
            : '0';
        let lyrics = [];
        let lyricElements = notes[i].querySelectorAll('lyric');
        lyricElements = lyricElements.length
          ? lyricElements
          : notes[i].querySelectorAll('verse');
        lyricElements.forEach((lyric) => {
          let j = lyric.getAttribute('number') || lyric.getAttribute('n');
          // Make lyrics 0 indexed
          lyrics[j - 1] = this._getLyric(lyric);
        });
        // Another way in musicXML to do chords is to just add a chord element inside a note
        // (in which case, the offset doesn't advance, and the note starts with the previous one).
        const isInternalChord = notes[i].querySelector('chord');
        let pitches = notes[i].querySelectorAll('pitch, note');
        pitches = pitches.length
          ? pitches
          : notes[i].getAttribute('oct')
            ? [notes[i]]
            : [];
        pitches.forEach((pitch) => {
          const pitchVal = this._getPitch(pitch);
          if (pitchVal > this.highNote) {
            this.highNote = pitchVal;
          }
          if (pitchVal < this.lowNote) {
            this.lowNote = pitchVal;
          }
          let id = pitch.getAttribute('xml:id') || `note-${Math.random()}`;
          this.data.measures[measureNumber].notes.push({
            duration: duration,
            id: id,
            lyrics: lyrics,
            offset: isInternalChord
              ? offset[partID + voice] - previousDuration
              : offset[partID + voice] || 0,
            pitch: pitchVal,
            voice: partID + voice
          });
          const numLyrics = lyrics.filter((lyric) => lyric).length;
          if (numLyrics > this.numVerses) {
            this.numVerses = numLyrics;
          }
          this.data.voices[partID + voice] = partID + voice;
          // Don't duplicate lyrics for subsequent notes.
          lyrics = [];
        });
        if (!isInternalChord) {
          offset[partID + voice] = (offset[partID + voice] || 0) + duration;
        }
        if (
          offset[partID + voice] > this.data.measures[measureNumber].duration
        ) {
          this.data.measures[measureNumber].duration = offset[partID + voice];
        }
        previousDuration = duration;
      }
      // Parse chord symbols from MEI
      let mdiv = measure.closest('mdiv');
      if (mdiv) {
        let staffDef = mdiv.querySelector('staffDef');
        measure.querySelectorAll('harm').forEach((harm) => {
          this.chordSymbols = true;
          let tstamp = parseFloat(harm.getAttribute('tstamp'));
          let ppq = staffDef.getAttribute('ppq');
          let meterunit = staffDef.getAttribute('meter.unit');
          this.data.measures[measureNumber].chordSymbols.push({
            text: harm.innerHTML,
            id: harm.getAttribute('xml:id'),
            offset: (tstamp - 1) * ppq * (4 / meterunit)
          });
        });
      }
    });

    // Compute some things about the song.
    this.noteRange = this.highNote - this.lowNote + 1;
    let durations = 0;
    let count = 0;
    this.data.measures.forEach((m) => {
      m.notes.forEach((n) => {
        count++;
        durations += n.duration;
      });
    });
    this.averageDuration = durations / count;

    // Assign numbers to the voices
    Object.keys(this.data.voices).forEach((voice, i) => {
      this.data.voices[voice] = i;
    });

    this.redoLayout();
  }

  redoLayout () {
    this.pages = [];
    this._createTitleSlide();
    super.redoLayout();
  }

  _configValues () {
    this.xScale = this.scale;
    this.yScale = this.scale / 6;
    this.fontSize = this.scale / 3;
  }

  // Expects this.pages to be [] to start with
  _createTitleSlide () {
    this.pages.push('');
    const title = this.data.title;
    let footerLines = this.data.footer ? this.data.footer.split('\n') : [];
    // TODO: Is there a built in way to wrap lines in SVG?
    // Manually wrap long title lines
    let lineLimit = 50;
    let titleLines = [title];
    let titleLength = title.length;
    if (titleLength > lineLimit) {
      titleLines = [];
      let charLimit = titleLength / Math.ceil(titleLength / lineLimit);
      let charCount = 0;
      let titleWords = title.split(' ');
      let start = 0;
      let end = 0;
      for (end = 0; end < titleWords.length; end++) {
        charCount += titleWords[end].length + 1;
        if (charCount > charLimit) {
          titleLines.push(titleWords.slice(start, end + 1).join(' '));
          charCount = 0;
          start = end + 1;
        }
      }
      if (start < titleWords.length) {
        titleLines.push(titleWords.slice(start, end).join(' '));
      }
    }
    const titleLinesCount = titleLines.length;
    const subtitle = this.data.subtitle;
    if (subtitle) {
      lineLimit = 100;
      // TODO: Is there a built in way to wrap lines in SVG?
      // Manually wrap long title lines
      let subtitleLength = subtitle.length;
      if (subtitleLength > lineLimit) {
        let charLimit = subtitleLength / Math.ceil(subtitleLength / lineLimit);
        let charCount = 0;
        let subtitleWords = subtitle.split(' ');
        let start = 0;
        let end = 0;
        for (end = 0; end < subtitleWords.length; end++) {
          charCount += subtitleWords[end].length + 1;
          if (charCount > charLimit) {
            titleLines.push(subtitleWords.slice(start, end + 1).join(' '));
            charCount = 0;
            start = end + 1;
          }
        }
        if (start < subtitleWords.length) {
          titleLines.push(subtitleWords.slice(start, end).join(' '));
        }
      } else {
        titleLines.push(subtitle);
      }
    }
    // Manually wrap long footer lines (indenting secondary portions of wrapped lines)
    lineLimit = 150;
    let newFooterLines = [];
    for (let i = 0; i < footerLines.length; i++) {
      let footerLine = footerLines[i].trim();
      let footerLength = footerLine.length;
      if (footerLength > lineLimit) {
        let charLimit = footerLength / Math.ceil(footerLength / lineLimit);
        let charCount = 0;
        let footerWords = footerLine.split(' ');
        let start = 0;
        let end = 0;
        for (end = 0; end < footerWords.length; end++) {
          charCount += footerWords[end].length + 1;
          if (charCount > charLimit) {
            newFooterLines.push(
              (end ? '' : '        ') +
                footerWords.slice(start, end + 1).join(' ')
            );
            charCount = 0;
            start = end + 1;
          }
        }
        if (start < footerWords.length) {
          newFooterLines.push(
            '        ' + footerWords.slice(start, end).join(' ')
          );
        }
      } else {
        newFooterLines.push(footerLine);
      }
    }
    footerLines = newFooterLines;
    this.pages[0] += `
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${this.width}px" height="${this.height}px" version="1.1" overflow="visible">
        <desc></desc>
        <defs></defs>
        <style type="text/css"></style>
        <svg class="definition-scale" color="black">
          <g class="page-margin">
    `;
    // Subtitle lines are half the size
    const subtitleFactor = 2;
    // The amount a baseline needs to be brought down when using baseline end to mimic baseline middle
    const baseAdjustment = 0.25;
    // If no subtitle, baseAdjustment brings the baseline down as though it had baseline middle
    // If subtitle, half baseAdjustment accounts for the second base baseAdjustment added to subtitle lines
    let base =
      titleLinesCount === titleLines.length
        ? baseAdjustment
        : baseAdjustment / subtitleFactor;
    for (let i = 0; i < titleLines.length; i++) {
      // In px; rest of values use em
      let fontSize = 42;
      // Amount of space to leave for title lines below this
      // Line height is 1.3, but that would be too much, so just use half the extra height
      let titleOffset = -1.15;
      // Amount of space to leave for subtitle lines below this
      let subtitleOffset = titleOffset / subtitleFactor;
      if (i >= titleLinesCount) {
        // This line is part of the subtitle, make it smaller
        fontSize /= subtitleFactor;
        // baseAdjustment brings its baseline down to match the main title's starting baseline
        // Another baseAdjustment brings baseline to the same baseline that the title would have with baseline middle
        base = baseAdjustment * 2;
        // Now that we are in the subtitle fontSize, the subtitleOffset can use the full titleOffset
        subtitleOffset *= subtitleFactor;
      }
      // Number of main title lines below this line
      let titleLinesBelow = Math.max(titleLinesCount - i - 1, 0);
      // Number of subtitle lines below this line
      let subtitleLinesBelow = Math.max(
        titleLines.length -
          titleLinesCount -
          Math.max(i - titleLinesCount + 1, 0),
        0
      );
      let dy = `${
        titleLinesBelow * titleOffset +
        subtitleLinesBelow * subtitleOffset +
        base
      }em`;
      this.pages[0] +=
        `<text x="50%" y="45%" dy="${dy}" dominant-baseline="end" text-anchor="middle" font-size="${fontSize}px"` +
        ` xml:space="preserve">${titleLines[i].trim()}</text>`;
    }
    this.pages[0] += `<text class="title-footer" x="0%" y="45%" font-size="12px" xml:space="preserve">`;
    for (let i = 0; i < footerLines.length; i++) {
      const dy = i === 0 ? '3.5em' : '1em';
      const footerLine = this._italicizeFooterLine(
        footerLines[i],
        '<tspan font-style="italic">',
        '</tspan>'
      );
      this.pages[0] += `<tspan x="15%" dy="${dy}">${footerLine}</tspan>`;
    }
    this.pages[0] += `
            </text>
          </g>
        </svg>
      </svg>
    `;
  }

  _italicizeFooterLine (footerLine, italicStart, italicEnd) {
    // Italicize the footer text marked with ***
    footerLine = footerLine.replaceAll(
      /\*\*\*(.*?)\*\*\*/g,
      `${italicStart}$1${italicEnd}`
    );
    if (footerLine.indexOf('***') !== -1) {
      footerLine = footerLine.replace('***', italicStart) + italicEnd;
    }
    return footerLine;
  }

  _getLyric (lyric) {
    if (!lyric) return '';
    let parts = lyric.querySelectorAll('text');
    if (!parts.length && lyric.querySelectorAll('syl').length) {
      // TODO: Is this if statement even necessary?
      parts = lyric.querySelectorAll('syl');
    }
    let text = '';
    for (let i = 0; i < parts.length; i++) {
      let part = parts[i];
      part = part.innerHTML;
      if (text) {
        text += '‿';
      }
      text += part;
    }
    let syllabic = lyric.querySelectorAll('syllabic')[0];
    syllabic = syllabic
      ? syllabic.innerHTML
      : lyric.querySelectorAll('syl')[0].getAttribute('wordpos');
    if (syllabic === 'begin' || syllabic === 'i') return text + '-';
    else if (syllabic === 'end' || syllabic === 't') return text + '\xa0';
    else if (syllabic === 'middle' || syllabic === 'm') return text + '-';
    else return text + '\xa0';
  }

  _getPitch (pitch) {
    let step =
      pitch.getAttribute('pname') || pitch.querySelector('step').innerHTML;
    let alter = pitch.querySelector('alter');
    if (alter) {
      alter = alter.innerHTML;
    } else if (pitch.getAttribute('accid.ges') === 'f') {
      alter = -1;
    } else if (pitch.getAttribute('accid.ges') === 's') {
      alter = 1;
    } else {
      alter = 0;
    }
    let octave =
      pitch.getAttribute('oct') || pitch.querySelector('octave').innerHTML;
    const stepMap = {
      C: 0,
      c: 0,
      D: 2,
      d: 2,
      E: 4,
      e: 4,
      F: 5,
      f: 5,
      G: 7,
      g: 7,
      A: 9,
      a: 9,
      B: 11,
      b: 11
    };
    // TODO: make sure that C flat gets placed in the correct octave.
    return stepMap[step] + parseInt(alter) + parseInt(octave) * 12;
  }
}
