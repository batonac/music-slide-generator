/* globals Document, XMLSerializer */
import { MusicToolkit } from '../js/MusicToolkit.js?v=3.0.0';

export class PianoRollToolkit extends MusicToolkit {
  getPageCount () {
    return this.pages.length;
  }

  /**
   * @brief Find the page that a specific note is on.
   */
  getPageWithElement (id) {
    // Search through the measures to find the current note.
    let measureIdx = this.data.measures.findIndex((m) => {
      return m && m.notes.find((note) => note.id === id);
    });

    // Find the page that contains that measure.
    let pageIdx = this.pages.findIndex((page) => {
      // The title page is a string, so we shouldn't call find on it
      return typeof page !== 'string' && page.find((m) => m.i === measureIdx);
    });
    return pageIdx;
  }

  redoLayout () {
    this.pages = [];
    this._createTitleSlide();
    this._assignMeasuresToPages();
  }

  renderToSVG (page) {
    if (page === 0) {
      // The title page is already SVG
      return this.pages[page];
    }
    let svg = new Document().createElement('svg');
    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    svg.setAttribute('class', 'piano-roll');
    svg.setAttribute('font-family', 'Monospace');
    svg.setAttribute('font-size', this.fontSize);
    svg.setAttribute('width', this.width);
    svg.setAttribute('height', this.height);
    let desc = new Document().createElement('desc');
    let defs = new Document().createElement('defs');
    let style = new Document().createElement('style');
    style.setAttribute('type', 'text/css');
    style.innerHTML = `svg g[class^=voice] text:not([data-verse-num="1"]) {
      font-style: italic;
    }`;
    let innerSvg = new Document().createElement('svg');
    innerSvg.setAttribute('class', 'definition-scale');
    innerSvg.setAttribute('color', 'black');
    svg.appendChild(desc);
    svg.appendChild(defs);
    svg.appendChild(style);
    svg.appendChild(innerSvg);
    let maxYOffset = -Infinity;
    this.pages[page].forEach((measurePlacement) => {
      let measure = this.data.measures[measurePlacement.i];
      if (measure) {
        let measureElement = this._measure(measure);
        if (measurePlacement.y > maxYOffset) {
          maxYOffset = measurePlacement.y;
        }
        measureElement.setAttribute('id', `measure${measurePlacement.i}`);
        measureElement.setAttribute(
          'transform',
          `translate(${measurePlacement.x} ${measurePlacement.y})`
        );
        innerSvg.appendChild(measureElement);
      }
    });
    if (this.adjustPageHeight && maxYOffset >= 0) {
      let adjustedHeight = this._getMeasureHeight() + maxYOffset;
      svg.setAttribute('height', adjustedHeight);
    }
    return new XMLSerializer().serializeToString(svg);
  }

  getOptions () {
    return this.options;
  }

  // Private functions

  _assignMeasuresToPages () {
    if (this.useSectionBreaks) {
      if (this.data.measures.some((m) => m.sectionBreak)) {
        let scale = this.width / this._getMaxSectionDuration();
        if (scale) {
          this.xScale = scale;
        }
      } else {
        this._debug(
          'useSectionBreaks is set, but no section breaks were found in this piece.'
        );
      }
    } else if (this.averageDuration > 50) {
      this.xScale = this.scale / Math.ceil(this.averageDuration / 2);
    }
    let rowHeight = this._getMeasureHeight();
    // TODO: Account for the title, allow different number of rows
    // on different slides.
    let yOffset = 0;
    if (!this.noHeader) {
      yOffset = this.fontSize * 3.0;
    }
    let rowsPerSlide = Math.floor((this.height - yOffset) / rowHeight);
    rowsPerSlide = rowsPerSlide > 1 ? rowsPerSlide : 2;
    this.pages.push([]);
    let j = 1;
    let row = 0;
    let xOffset = 0;
    let validMeasureCount = 0;
    for (let i = 1; i <= this.data.measures.length; i++) {
      let measure = this.data.measures[i];
      if (measure) {
        validMeasureCount++;
        let mWidth = this._getMeasureWidth(measure);
        if (
          xOffset + mWidth > this.width ||
          (this.useSectionBreaks &&
            measure.sectionBreak &&
            validMeasureCount !== 1)
        ) {
          xOffset = 0;
          if (row + 1 < rowsPerSlide) {
            row++;
          } else {
            j++;
            this.pages[j] = [];
            row = 0;
            yOffset = 0;
          }
        }
        let xTransform = xOffset;
        let yTransform = yOffset + row * rowHeight;
        xOffset += mWidth;
        this.pages[j].push({ x: xTransform, y: yTransform, i: i });
      }
    }
  }

  _debug (message) {
    console.log(`PianoRollToolkit: ${message}`);
  }

  _getMaxSectionDuration () {
    let msd = -Infinity;
    let sectionDur = 0;
    for (let i = 0; i <= this.data.measures.length; i++) {
      let measure = this.data.measures[i];
      if (measure) {
        sectionDur += measure.duration;
        if (sectionDur > msd) {
          msd = sectionDur;
        }
        if (measure.sectionBreak) {
          sectionDur = 0;
        }
      }
    }
    return msd;
  }
  _getMeasureHeight () {
    return (
      this.noteRange * this.yScale +
      2 * (this.fontSize * (this.numVerses + this.chordSymbols))
    );
  }
  _getMeasureWidth (measure) {
    return measure.duration * this.xScale;
  }

  _getTitleBlock () {
    let titleBlock = new Document().createElement('g');
    let title = new Document().createElement('text');
    title.innerHTML = this.data.title;
    title.setAttribute('dy', this.fontSize);
    title.setAttribute(
      'x',
      this.data.title.length * (-0.7 * this.fontSize) * 0.5
    );
    title.setAttribute('dx', '50%');
    titleBlock.appendChild(title);

    let lyricist = new Document().createElement('text');
    lyricist.innerHTML = this.data.lyricist;
    lyricist.setAttribute('y', this.fontSize);
    lyricist.setAttribute('dy', this.fontSize);
    lyricist.setAttribute('style', 'font-size: 70%');
    titleBlock.appendChild(lyricist);

    let composerNewLine =
      (this.data.lyricist.length + this.data.composer.length) *
        (0.7 * this.fontSize * 0.7) >
      this.width;

    let composer = new Document().createElement('text');
    composer.innerHTML = this.data.composer;
    composer.setAttribute('y', this.fontSize * (1 + composerNewLine));
    composer.setAttribute('dy', this.fontSize);
    composer.setAttribute('style', 'font-size: 70%');
    composer.setAttribute(
      'x',
      this.data.composer.length * (-0.65 * this.fontSize * 0.7)
    );
    composer.setAttribute('dx', '100%');
    titleBlock.appendChild(composer);

    return titleBlock;
  }
  _getFooterBlock (footerFontSize) {
    let footerBlock = new Document().createElement('g');
    let lineCount = 0;
    if (this.data.footer) {
      // TODO: Should we do anything if the footer line count is above 4 to avoid collision?
      const footerLines = this.data.footer.split('\n').reverse();
      // Iterate through footer lines in reverse order (to stack on top of each other)
      for (let i = 0; i < footerLines.length; i++) {
        let footerLine = footerLines[i].trim();
        if (footerLine) {
          let footerText = new Document().createElement('text');
          footerText.innerHTML = this._italicizeFooterLine(
            footerLine,
            '<tspan font-style="italic">',
            '</tspan>'
          );
          // Place each line of the footer slightly above the last
          footerText.setAttribute(
            'dy',
            -footerFontSize * (lineCount * 1.2 + 0.7)
          );
          footerText.setAttribute(
            'style',
            'font-size: ' + footerFontSize + 'px;'
          );
          footerText.setAttribute('y', '100%');
          footerText.setAttribute('x', 0);
          footerBlock.appendChild(footerText);
          // Only increment the line count after non-empty lines
          lineCount++;
        }
      }
    }
    this.footerHeight = footerFontSize * (lineCount * 1.2);
    return footerBlock;
  }
  _measure (measure) {
    let measureElement = new Document().createElement('g');
    let notes = measure.notes;
    for (let i = 0; i < notes.length; i++) {
      let note = notes[i];
      let x = note.offset;
      let w = note.duration;
      let y = this.highNote - note.pitch;
      let h = 1;
      let lyrics = note.lyrics;
      measureElement.appendChild(
        this._rectangle(x, y, w, h, lyrics, note.voice, note.id)
      );
    }
    measure.chordSymbols.forEach((cs) => {
      measureElement.appendChild(this._renderChordSymbol(cs));
    });
    return measureElement;
  }

  _rectangle (x, y, w, h, lyrics, voice, id) {
    let g = new Document().createElement('g');
    g.setAttribute('class', `voice${this.data.voices[voice]}`);
    let sx = this.xScale * x;
    let sw = this.xScale * w;
    let sy = this.yScale * y + this.chordSymbols * this.fontSize;
    let sh = this.yScale * h;
    let rect = new Document().createElement('rect');
    // Make the rectangles rounded.
    let diameter = this.yScale;
    rect.setAttribute('x', sx + diameter / 2);
    rect.setAttribute('width', sw - diameter);
    rect.setAttribute('y', sy + diameter / 2);
    let height = sh - diameter;
    rect.setAttribute('height', height > 0 ? height : 1);
    rect.setAttribute('stroke-width', diameter);
    rect.setAttribute('stroke-linejoin', 'round');
    g.appendChild(rect);
    lyrics.forEach((lyric, i) => {
      if (lyric) {
        let text = new Document().createElement('text');
        text.setAttribute('x', sx);
        text.setAttribute('data-textlength', sw);
        text.setAttribute('lengthAdjust', 'spacingAndGlyphs');
        // When data-verse-num is not 1, the text will be italicized
        text.setAttribute('data-verse-num', i + 1);
        text.setAttribute('dx', 1);
        text.setAttribute(
          'y',
          this.noteRange * this.yScale + (i + this.chordSymbols) * this.fontSize
        );
        text.setAttribute('dy', this.fontSize);
        text.innerHTML = lyric;
        this._squishText(text);

        g.appendChild(text);
      }
    });
    g.setAttribute('id', id);
    return g;
  }
  _renderChordSymbol (cs) {
    let text = new Document().createElement('text');
    let sx = this.xScale * cs.offset;
    text.setAttribute('x', sx);
    text.setAttribute('y', 0);
    text.setAttribute('dy', this.fontSize);
    text.setAttribute('id', cs.id);
    text.innerHTML = cs.text;
    return text;
  }
  /**
   * @brief Squish text so it doesn't go beyond the boundaries of its box.
   *  Also possibly removes hypens or adds non-breaking spaces to squished text elements.
   * @param el The element that you want to squish the text on.
   * @precondition The text in the element ends with a non-breaking space if it is the end of a word.
   */
  _squishText (el) {
    // If there is no text here, we don't have to do anything.
    if (typeof el.childNodes[0] === 'undefined') return;
    var text = el.childNodes[0].nodeValue;
    // Setting a specific letter width isn't perfect since "One" is wider than "ly,",
    // For now, we are using a monospace font to account for this.
    var widthPerLetter = this.fontSize * 0.7;
    var boxWidth = el.getAttribute('data-textlength');

    // Add a hyphen if it doesn't end in a hypen or a non-breaking space.
    if (!text.match(/[\xA0-]$/)) {
      text += '-';
    }

    if (text.length * widthPerLetter >= boxWidth) {
      // Apply the textLength attribute if we need to squish these letters.
      el.setAttribute('textLength', boxWidth);

      // If we need to squish this letter, it's okay to remove any trailing hyphens,
      // as long as removing those won't stretch the letter out.
      // (this syllable is the middle of a word, but is squished against its continuation)
      if ((text.length - 1) * widthPerLetter >= boxWidth) {
        text = text.replace(/-$/, '');
      }
    } else {
      el.removeAttribute('textLength');
    }
    el.innerHTML = text;
  }
}
