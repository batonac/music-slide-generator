/* globals fetch, jQuery */
export class RevealMusicXML {
  constructor (ToolkitType, transformer, highlightNotes = true) {
    this.MIDIDELAY = 380;
    this.TIMEMAPOFFSET = 0.3;
    this.ToolkitType = ToolkitType;
    this.toolkits = [];
    this.players = [];
    this.timemaps = [];
    this.playing = false;
    this.transformer = transformer;
    // TODO: Use Reveal object passed to plugin when that is available.
    // https://github.com/hakimel/reveal.js/issues/2405
    // eslint-disable-next-line no-undef
    this.reveal = Reveal;
    this.resizeTimeout = undefined;
    this.shouldAutoSkip = false;
    this.highlightNotes = highlightNotes;
    this.currentLowKi = -1;
    this.shouldPause = false;
    this.timemapMode = '';
    this.timemapKit = '';
    this.textOnlyTimemap = false;
    this.timestampInProgress = {};
    this.systems = [];
    this.currentSystemNum = 0;
    this.startOfSystem = true;
    this.playbackRates = [];
    this.defaultTempos = [];
    this.currentTempos = [];
    this.earlyTime = 0;
    this.previousTime = 0;
    this.iframePlayerTypes = [
      'YouTubePlayer',
      'BandcampPlayer',
      'SpotifyPlayer',
      'AppleMusicPlayer'
    ];
    this.youtubePlayerReady = false;
    this.toolkitsReady = false;
    this.lyricsOffset = 0;
    this.translationOffset = 0;
    this.resolutions = [
      [800, 600],
      [960, 720],
      [1024, 768],
      [1280, 960],
      [1600, 1200]
    ];
    this.resolutionIdx = 2;
    this.width = this.resolutions[this.resolutionIdx][0];
    this.height = this.resolutions[this.resolutionIdx][1];
    this.staveCounts = [];
    // The number of additional lines in this song's lyrics
    this.translationCounts = [];
    // TODO: These values are dependent on some combination of unit, lyric size, and the font we use,
    //  should we calculate them from unit and lyric size?
    // The amount of staffDeff spacing which doesn't cause systems to increase in height
    this.baseStaffDefSpacing = 22;
    // The amount of additional staffDeff spacing which we want to increase system height by
    this.additionalStaffDefSpacing = 2;
    // The amount of additional staffDeff spacing per translation line
    this.additionalTranslationStaffDefSpacing = 1;
    // The amount of staffDeff spacing which each additional lyric line adds to
    //  the amount of staffDeff spacing which doesn't cause systems to increase in height
    this.translationUnitDiff = 9;
    // The scaling factor for the size of flags
    this.flagSizeScaling = 0.7;
  }

  /**
   * @brief The init function will be called by Reveal when this is loaded.
   * @return A promise.
   */
  init () {
    this._setBackgroundImage();
    if (typeof this.ToolkitType === 'undefined') {
      throw new Error(
        'RevealMusicXML needs to be constructed with a rendering toolkit.'
      );
    }
    if (typeof this.transformer === 'undefined') {
      // Create a dummy transformer that does no transformation.
      this.transformer = { transform: (data, transformation) => data };
    }
    this.reveal.addKeyBinding(
      { keyCode: 77, key: 'M', description: 'Play/Pause audio' },
      this._playPause.bind(this)
    );
    return this._processSlides()
      .then(() => Promise.resolve())
      .then(() => {
        this.toolkitsReady = true;
        this.initAllPlayers();
      });
  }

  // Private methods

  _setBackgroundImage () {
    const section = document.querySelector('[data-background-image]');
    if (section) {
      const url = encodeURI(section.getAttribute('data-background-image'));
      const backgrounds = document.querySelector('div.backgrounds');
      if (backgrounds) {
        // I think this is made by revealjs, it causes issues with images, and doesn't seem necessary, so remove it
        backgrounds.remove();
      }
      document.body.style.backgroundImage = `url(${url})`;
      document.body.style.backgroundRepeat = 'no-repeat';
      document.body.style.backgroundSize = 'cover';
      document.body.style.backgroundPosition = 'center center';
    }
  }

  _unhighlightElementsWithNoteID (noteid) {
    let notes = document.querySelectorAll(`[id^=${noteid}`);
    notes.forEach((note) => {
      if (note) {
        note.classList.remove('highlightedNote');
      }
    });
  }

  _highlightElementsWithNoteID (noteid, chordIDs) {
    let notes = document.querySelectorAll(`[id^=${noteid}]`);
    notes.forEach((note) => {
      if (note) {
        /* If this note is the child of the chord, we also want to highlight the chord. */
        if (note.parentElement.id.startsWith('chord-')) {
          chordIDs.push(note.parentElement.id);
          note.parentElement.classList.add('highlightedNote');
        }
        note.classList.add('highlightedNote');
      }
    });
  }

  _highlightAtTime (time) {
    let thisToolkit = this.toolkits[this.playerToolkitNum];
    let elementsAtTime = thisToolkit.getElementsAtTime(time);
    if (this.timemapMode !== 'create') {
      let millisecEarly =
        50 *
        (this.defaultTempos[this.playerToolkitNum] /
          this.currentTempos[this.playerToolkitNum]);
      // Determine the first notes which are on the page millisecEarly from now
      let earlyTime =
        this.players[this.playerToolkitNum].getTimestamp() + millisecEarly;
      if (typeof this.timemaps[this.playerToolkitNum] !== 'undefined') {
        earlyTime =
          this._timemap(
            earlyTime / 1000,
            this.timemaps[this.playerToolkitNum],
            false
          ) * 1000;
      }
      let elementsInFuture = thisToolkit.getElementsAtTime(
        this.earlyTime ? this.earlyTime : earlyTime
      );
      // If the note(s) 0.3 seconds (in the base tempo) from now are on the next page, highlight those instead
      if (
        typeof elementsAtTime.page !== 'undefined' &&
        typeof elementsInFuture.page !== 'undefined' &&
        elementsAtTime.page > 0 &&
        elementsInFuture.page > 0 &&
        elementsAtTime.page !== elementsInFuture.page
      ) {
        this.earlyTime = this.earlyTime ? this.earlyTime : earlyTime;
        elementsAtTime = elementsInFuture;
      } else {
        this.earlyTime = 0;
      }
    }
    if (typeof elementsAtTime.page !== 'undefined' && elementsAtTime.page > 0) {
      if (
        elementsAtTime.page - 1 !== this.reveal.getState().indexv ||
        this.reveal.getState().indexh !==
          this._getIndexHForToolkit(this.playerToolkitNum)
      ) {
        this.reveal.slide(
          this._getIndexHForToolkit(this.playerToolkitNum),
          elementsAtTime.page - 1
        );
      }
      let ids = this.highlightedIDs || [];
      if (elementsAtTime.notes.length > 0 && ids !== elementsAtTime.notes) {
        ids.forEach((noteid) => {
          if (jQuery.inArray(noteid, elementsAtTime.notes) === -1) {
            this._unhighlightElementsWithNoteID(noteid);
          }
        });
        ids = elementsAtTime.notes;
        let chordIDs = [];
        ids.forEach((noteid) => {
          this._highlightElementsWithNoteID(noteid, chordIDs);
        });
        this.highlightedIDs = ids.concat(chordIDs);
      }
    }
  }

  _debug (message) {
    console.log(`RevealMusicXML: ${message}`);
  }

  _getAllToolkitNums () {
    let toolkitNums = [];
    let sections = jQuery('section[data-musicxml]');
    for (let i = 0; i < sections.length; i++) {
      let match = sections[i].id.match(/RevealMusicXML(\d*)/);
      if (match) {
        toolkitNums.push(parseInt(match[1]));
      }
    }
    return toolkitNums;
  }
  _getCurrentToolkitNum () {
    let $present = jQuery('section.present');
    if ($present.length) {
      let presentID = $present.attr('id');
      let match = presentID
        ? presentID.match(/RevealMusicXML(\d*)/)
        : undefined;
      if (match) {
        return parseInt(match[1]);
      }
    }
    return null;
  }
  _getNextToolkitNum () {
    let $present = jQuery('section.present');
    if ($present.length) {
      let $next = $present.next('section[data-musicxml]');
      if ($next.length) {
        let nextID = $next.attr('id');
        let match = nextID ? nextID.match(/RevealMusicXML(\d*)/) : undefined;
        if (match) {
          return parseInt(match[1]);
        }
      }
    }
    return null;
  }
  _getIndexHForToolkit (toolkitNum) {
    let $stack = jQuery(`#RevealMusicXML${toolkitNum}`);
    if ($stack.length) {
      return $stack.parent().children().toArray().indexOf($stack[0]);
    }
    return null;
  }

  _loadExternalMusicXML (section) {
    const url = section.getAttribute('data-musicxml');
    const transformation = section.getAttribute('data-musicxml-transform');
    return fetch(url)
      .then((res) => {
        if (res.ok) {
          return res.text();
        } else {
          section.innerHTML = 'Failed to load.';
          console.error('Failed to load ' + url);
          return '';
        }
      })
      .then((text) => this.transformer.transform(text, transformation, true))
      .then((text) => {
        this._slidify(
          section,
          text,
          this.transformer.transform(text, transformation)
        );
      });
  }

  // From https://ourcodeworld.com/articles/read/189/how-to-create-a-file-and-generate-a-download-with-javascript-in-the-browser-without-a-server
  _download (filename, text) {
    var element = document.createElement('a');
    element.setAttribute(
      'href',
      'data:text/plain;charset=utf-8,' + encodeURIComponent(text)
    );
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }

  /* Hooks for this.players[i]. */
  _playerEnd () {
    if (this.timemapMode === 'create') {
      let timemapText = '';
      for (const xmlTime in this.timestampInProgress) {
        timemapText += `${xmlTime}\t${this.timestampInProgress[xmlTime]}\n`;
      }

      // Download the timemap
      this._download('timemap.txt', timemapText);
    }
  }
  _playerStop () {
    if (typeof this.highlightedIDs !== 'undefined') {
      this.highlightedIDs.forEach((noteid) => {
        this._unhighlightElementsWithNoteID(noteid);
      });
    }
    this.playing = false;
    this._playChangeControls();
  }
  _playerUpdate (time, isIframePlayer) {
    this.shouldAutoSkip = true;
    if (this.highlightNotes === false || this.timemapMode === 'create') {
      return;
    }
    let vrvTime = Math.max(0, time - this.MIDIDELAY);
    if (typeof this.timemaps[this.playerToolkitNum] !== 'undefined') {
      // TODO: Figure out if there needs to be a different MIDIDELAY added.
      vrvTime =
        this._timemap(vrvTime / 1000, this.timemaps[this.playerToolkitNum]) *
        1000;
    }
    if (
      !isIframePlayer ||
      typeof this.timemaps[this.playerToolkitNum] !== 'undefined'
    ) {
      this._highlightAtTime(vrvTime);
    }
    if (this.shouldPause) {
      this._playPause();
      this.shouldPause = false;
    }
  }

  /**
   * @brief Interpolate adjusted time from a map of input => output.
   */
  _timemap (time, map, checkPause = true) {
    if (typeof map[time] !== 'undefined') {
      if (checkPause) {
        this._shouldPause(map[time]);
      }
      return map[time];
    }
    let keys = Object.keys(map);
    let lowKi = -1;
    let highKi = keys.length;
    // Binary search for closest keys
    while (1 + lowKi < highKi) {
      const midKi = lowKi + ((highKi - lowKi) >> 1);
      if (keys[midKi] > time) {
        highKi = midKi;
      } else {
        lowKi = midKi;
      }
    }
    if (lowKi === -1) return 0;
    // This attempts to highlight the final note
    // TODO: Find a better solution
    if (highKi === keys.length) return this.previousTime + 0.1;
    if (checkPause) {
      this._shouldPause(map[keys[lowKi]]);
    }
    this.previousTime = this._map(
      time,
      keys[lowKi],
      keys[highKi],
      map[keys[lowKi]],
      map[keys[highKi]]
    );
    return this.previousTime;
  }
  _map (x, inMin, inMax, outMin, outMax) {
    return ((x - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
  }
  /**
   * @brief For use when testing a timemap:
   *  Check if we have reached a new point in the timemap,
   *  if so, record new position and indicate that player should pause.
   */
  _shouldPause (low) {
    if (this.timemapMode === 'test' && this.currentLowKi !== low) {
      this.currentLowKi = low;
      this.shouldPause = true;
    }
  }

  _playChangeControls (isIframePlayer = false) {
    this.reveal.configure({
      controls: !this.playing || !this.highlightNotes || isIframePlayer
    });
  }

  _initPlayer (i) {
    if (typeof window['VoidPlayer'] === 'undefined') {
      this._debug('base audio player does not exist. Audio will not play.');
      return {};
    }
    let PlayerType = window['VoidPlayer'];
    let param;

    let present = document.getElementsByClassName(`present`);
    this.timemapMode = present.length
      ? present.item(0).getAttribute('data-timemap-mode')
      : '';
    this.timemapKit = present.length
      ? JSON.parse(
        present.item(0).getAttribute('data-musicxml-toolkit') ||
          '{"toolkit":"MusicToolkit"}'
      ).toolkit
      : 'MusicToolkit';
    this.textOnlyTimemap = this.timemapKit === 'TextOnlyToolkit';
    // If the user is creating a timemap file...
    if (this.timemapMode === 'create') {
      // When they press space...
      this.reveal.addKeyBinding(
        { keyCode: 32, key: ' ', description: 'Record time' },
        function () {
          if (
            this.playing &&
            this.systems.length >= this.currentSystemNum + 1
          ) {
            // Get the time in the audio recording
            let player = this.players[this.playerToolkitNum];
            let audioTime = player.getTimestamp();
            // Get the current time in the midi file
            let toolkit = this.toolkits[this.playerToolkitNum];
            let thisNoteID = '';
            if (!this.textOnlyTimemap && this.startOfSystem) {
              thisNoteID = this.systems
                .eq(this.currentSystemNum)
                .find('.note')
                .first()
                .attr('id');
            } else {
              thisNoteID = this.systems
                .eq(this.currentSystemNum)
                .find('.note')
                .last()
                .attr('id');
            }
            let midiTime = toolkit.getTimeForElement(thisNoteID);
            // Record time
            this.timestampInProgress[midiTime / 1000] =
              audioTime / 1000 - this.TIMEMAPOFFSET;
            console.log(midiTime / 1000, audioTime / 1000 - this.TIMEMAPOFFSET);
            // Update to end of this system or next system
            if (!this.textOnlyTimemap && this.startOfSystem) {
              this.startOfSystem = false;
            } else {
              this.startOfSystem = true;
              this.currentSystemNum += 1;
            }
            if (this.systems.length > this.currentSystemNum) {
              // If any system before the last one or start of the last one, highlight next notes
              let nextNoteID = '';
              if (!this.textOnlyTimemap && this.startOfSystem) {
                nextNoteID = this.systems
                  .eq(this.currentSystemNum)
                  .find('.note')
                  .first()
                  .attr('id');
              } else {
                nextNoteID = this.systems
                  .eq(this.currentSystemNum)
                  .find('.note')
                  .last()
                  .attr('id');
              }
              let nextTime = toolkit.getTimeForElement(nextNoteID);
              this._highlightAtTime(nextTime + 10);
            } else {
              // If end of last system, remove all highlights
              this.highlightedIDs.forEach((noteid) => {
                this._unhighlightElementsWithNoteID(noteid);
              });
            }
          }
        }.bind(this)
      );
      // When they press backspace...
      this.reveal.addKeyBinding(
        { keyCode: 8, key: 'Backspace', description: 'Delete previous time' },
        function () {
          if (
            this.playing &&
            (this.currentSystemNum > 0 ||
              !this.startOfSystem ||
              this.textOnlyTimemap)
          ) {
            // Update to end of prev system or start of this system
            if (this.textOnlyTimemap || this.startOfSystem) {
              this.startOfSystem = false;
              this.currentSystemNum -= 1;
            } else {
              this.startOfSystem = true;
            }
            // Get the time of the first note in the previous system in the midi
            let toolkit = this.toolkits[this.playerToolkitNum];
            let prevNoteID = '';
            if (!this.textOnlyTimemap && this.startOfSystem) {
              prevNoteID = this.systems
                .eq(this.currentSystemNum)
                .find('.note')
                .first()
                .attr('id');
            } else {
              prevNoteID = this.systems
                .eq(this.currentSystemNum)
                .find('.note')
                .last()
                .attr('id');
            }
            let prevTime = toolkit.getTimeForElement(prevNoteID);
            // Delete previous time and highlight previous note
            delete this.timestampInProgress[prevTime / 1000];
            this._highlightAtTime(prevTime + 10);
          }
        }.bind(this)
      );
    }

    let root = document.getElementById(`RevealMusicXML${i}`);
    this.playbackRates[i] = Number(root.getAttribute('data-playback-rate'));
    if (!this.playbackRates[i] || this.playbackRates[i] <= 0) {
      this.playbackRates[i] = 1;
    }
    this.defaultTempos[i] = Number(root.getAttribute('data-default-tempo'));
    if (!this.defaultTempos[i] || this.defaultTempos[i] <= 0) {
      this.defaultTempos[i] = 120;
    }
    this.currentTempos[i] = Number(root.getAttribute('data-current-tempo'));
    if (!this.currentTempos[i] || this.currentTempos[i] <= 0) {
      this.currentTempos[i] = 120;
    }

    let audio = root.getAttribute('data-musicxml-audio');
    if (audio && audio !== 'none') {
      if (
        typeof window['MIDIPlayer'] !== 'undefined' &&
        audio.indexOf('.mid') !== -1
      ) {
        PlayerType = window['MIDIPlayer'];
        param = audio;
      } else if (
        typeof window['MIDIPlayer'] !== 'undefined' &&
        typeof window['verovio'] !== 'undefined' &&
        (audio.indexOf('.musicxml') !== -1 || audio.indexOf('.mei') !== -1)
      ) {
        PlayerType = window['XMLPlayer'];
        param = [audio, this.toolkits[i].getOptions()];
      } else if (
        typeof window['YouTubePlayer'] !== 'undefined' &&
        (audio.indexOf('youtube.com/') !== -1 ||
          audio.indexOf('://youtu.be/') !== -1)
      ) {
        PlayerType = window['YouTubePlayer'];
        param = audio;
      } else if (
        typeof window['SpotifyPlayer'] !== 'undefined' &&
        audio.indexOf('spotify.com/') !== -1
      ) {
        PlayerType = window['SpotifyPlayer'];
        param = audio;
      } else if (
        typeof window['BandcampPlayer'] !== 'undefined' &&
        audio.indexOf('bandcamp.com/') !== -1
      ) {
        PlayerType = window['BandcampPlayer'];
        param = audio;
      } else if (
        typeof window['AppleMusicPlayer'] !== 'undefined' &&
        audio.indexOf('music.apple.com/') !== -1
      ) {
        PlayerType = window['AppleMusicPlayer'];
        param = audio;
      } else if (typeof window['AudioPlayer'] !== 'undefined') {
        PlayerType = window['AudioPlayer'];
        param = audio;
      }
    } else if (audio !== 'none') {
      PlayerType = window['MIDIPlayer'];
      param = this.toolkits[i].renderToMIDI();
    }
    return new PlayerType(
      param,
      this._playerUpdate.bind(this),
      this._playerStop.bind(this),
      this._playerEnd.bind(this),
      this.playbackRates[i]
    );
  }

  _fetchTimeMap (i) {
    let root = document.getElementById(`RevealMusicXML${i}`);
    this.timemaps[i] = {};
    if (typeof root.dataset['musicxmlAudioTimemap'] !== 'undefined') {
      fetch(root.dataset['musicxmlAudioTimemap'])
        .then((res) => {
          if (res.ok) {
            return res.text();
          } else {
            // Disable highlighting if the timemap fails to load
            this.highlightNotes = false;
            this.highlightedIDs.forEach((noteid) => {
              this._unhighlightElementsWithNoteID(noteid);
            });
            throw new Error(
              'Failed to load ' + root.dataset['musicxmlAudioTimemap']
            );
          }
        })

        .then((text) => {
          let lines = text.split('\n');
          for (let j = 0; j < lines.length; j++) {
            if (lines[j] && lines[j][0] !== '#') {
              let parts = lines[j].split('\t');
              // Key is the time of the audio file (coerce to float),
              // Value is the time of the music document.
              this.timemaps[i][parseFloat(parts[1]) + 0.001] = parseFloat(
                parts[0]
              );
            }
          }
        });
    } else {
      this.timemaps[i] = undefined;
    }
  }

  _playPause () {
    this.playerToolkitNum = this._getCurrentToolkitNum();
    if (this.playerToolkitNum === null) {
      // If this is a musicxml that failed to load, do nothing
      return;
    }
    let hln;
    if (
      (hln = jQuery('section.present')[0].closest(
        '[data-musicxml-highlightnotes]'
      ))
    ) {
      this.highlightNotes = Boolean(hln.dataset.musicxmlHighlightnotes);
    }
    if (this.playing) {
      for (let i = 0; i < this.players.length; i++) {
        if (typeof this.players[i] !== 'undefined') {
          if (i !== this.playerToolkitNum) {
            this.players[i].stop();
          } else {
            this.players[i].pause();
          }
        }
      }
      this.playing = false;
    } else {
      if (typeof this.players[this.playerToolkitNum] === 'undefined') {
        this.players[this.playerToolkitNum] = this._initPlayer(
          this.playerToolkitNum
        );
        this.players[this.playerToolkitNum].show();
      }
      if (!this.players[this.playerToolkitNum].toolkitSetUp) {
        if (this.timemapMode === 'create') {
          this.systems = jQuery('.reveal').find(jQuery('.system'));
          if (this.systems.length > 0) {
            let toolkit = this.toolkits[this.playerToolkitNum];
            let firstTime = toolkit.getTimeForElement(
              this.systems.eq(0).find('.note').attr('id')
            );
            this._highlightAtTime(firstTime + 10);
          }
        } else {
          this._fetchTimeMap(this.playerToolkitNum);
        }
        this.players[this.playerToolkitNum].toolkitSetUp = true;
      }
      // https://stackoverflow.com/a/519157
      if (typeof this.players[this.playerToolkitNum].params !== 'undefined') {
        this.players[this.playerToolkitNum].play();
        this.playing = true;
      }
    }
    const isIframePlayer = this.iframePlayerTypes.includes(
      this.players[this.playerToolkitNum].constructor.name
    );
    this._playChangeControls(isIframePlayer);
  }

  initAllPlayers () {
    // Only initialize players once youtube player is loaded and toolkits exist
    // Idea from https://stackoverflow.com/a/13960848
    if (this.toolkitsReady && this.youtubePlayerReady) {
      this.toolkits.forEach(function (element, index) {
        if (typeof this.players[index] === 'undefined') {
          this.players[index] = this._initPlayer(index);
        }
      }, this);
      this.playerToolkitNum = this._getCurrentToolkitNum();
      this.players[this.playerToolkitNum].show();
    }
  }

  listenForSlideChange () {
    // Whenever the slide changes...
    this.reveal.addEventListener('slidechanged', () => {
      let oldToolkitNum = this.playerToolkitNum;
      this.playerToolkitNum = this._getCurrentToolkitNum();
      // If the new slide is a different player, we need to...
      if (oldToolkitNum !== this.playerToolkitNum) {
        if (typeof this.players[oldToolkitNum] !== 'undefined') {
          // Hide/pause the old player
          this.players[oldToolkitNum].hide();
          this.players[oldToolkitNum].pause();
        }
        if (typeof this.players[this.playerToolkitNum] !== 'undefined') {
          // Show/pause the new one
          this.players[this.playerToolkitNum].show();
          this.players[this.playerToolkitNum].pause();
        }
        // Ensure that DP doesn't think the player is playing
        this._playerStop();
      }
    });
  }

  _processSlides () {
    let promises = [];
    document.querySelectorAll('[data-musicxml]').forEach((section) => {
      if (section.getAttribute('data-musicxml').length) {
        promises.push(this._loadExternalMusicXML(section));
      } else {
        this._slidify(
          section,
          this.transformer.transform(
            section.querySelector('script[type="text/template"]').innerHTML,
            section.getAttribute('data-musicxml-transform'),
            true
          ),
          this.transformer.transform(
            section.querySelector('script[type="text/template"]').innerHTML,
            section.getAttribute('data-musicxml-transform')
          )
        );
      }
    });
    return Promise.all(promises);
  }

  _render (section, toolkit, tkIdx) {
    const isMusic = toolkit.constructor.name === 'MusicToolkit';
    section.innerHTML = '';
    let options = toolkit.getOptions();
    if (isMusic) {
      let mei = toolkit.getMEI();
      // Intermediate-processing
      mei = this._adjustMEI(mei, tkIdx);
      // Convert MEI => SVG
      toolkit.loadData(mei);
      delete options.transpose;
      toolkit.setOptions(options);
    }
    let count = toolkit.getPageCount();
    let svg = '';
    for (let i = 0; i < count; i++) {
      let cSection = section.appendChild(document.createElement('section'));
      svg = toolkit.renderToSVG(i);
      // Post-processing
      if (isMusic) {
        cSection.innerHTML = this._adjustSVG(
          svg,
          tkIdx,
          options.unit,
          options.lyricSize
        );
      } else {
        cSection.innerHTML = svg;
      }
    }
  }
  _reslidify () {
    this.toolkits.forEach((toolkit, i) => {
      this._setOptions(toolkit);
      toolkit.redoLayout();
      let section = document.getElementById(`RevealMusicXML${i}`);
      this._render(section, toolkit, i);
    });
    let indices = this.reveal.getIndices();
    this.reveal.slide(indices.h, indices.v, indices.f);
  }

  _setOptions (toolkit) {
    let zoom = 60;
    this._applyRevealResolution();
    let defaultOptions = {
      pageHeight: this.height * (100 / zoom),
      pageWidth: this.width * (100 / zoom),
      scale: zoom,
      breaks: 'line',
      footer: 'none',
      header: 'none',
      adjustPageHeight: true,
      minLastJustification: 0,
      lyricTopMinMargin: 8,
      unit: 9,
      lyricSize: 7,
      // See the spacing attribute on staffDef elements for how we control this directly
      // See: https://github.com/rism-digital/verovio/discussions/3394
      spacingStaff: 0,
      spacingSystem: 0,
      bottomMarginHeader: 0,
      topMarginPgFooter: 0,
      font:
        window.getComputedStyle(document.documentElement)['font-family'] ||
        'Leipzig',
      slurMidpointThickness: 0.3,
      tieMidpointThickness: 0.3,
      // Labels each g.verse element in the SVG with its lyric number
      svgAdditionalAttribute: 'verse@n'
    };
    let i = this.toolkits.indexOf(toolkit);
    let options = document
      .getElementById(`RevealMusicXML${i}`)
      .getAttribute('data-musicxml-toolkit');
    options = JSON.parse(options || '{}').options || {};
    toolkit.setOptions({ ...defaultOptions, ...options });
    // 5 because the SVG pixels are 10 times smaller than the page pixels, and we need 1/2 the height change
    this.lyricsOffset =
      this.additionalStaffDefSpacing * defaultOptions.unit * 5;
    this.translationOffset =
      this.additionalTranslationStaffDefSpacing * defaultOptions.unit * 10;
  }

  _getHasCollisions () {
    // Calculate whether there is a collision between each syl element in each slide by making each slide active
    let sections = jQuery('div.slides section section');
    let hasCollision = false;
    sections.each((key, section) => {
      let originalClass = section.getAttribute('class');
      section.setAttribute('class', 'present');
      let syls = section.getElementsByClassName('syl');
      let bounds = {};
      for (let j = 0; j < syls.length; j++) {
        const rect = syls[j].getBoundingClientRect();
        const roundedBottom = Math.round(rect.bottom);
        if (bounds[roundedBottom] === undefined) {
          bounds[roundedBottom] = [];
        }
        const bound = [rect.left, rect.right];

        for (let i = 0; i < bounds[roundedBottom].length; i++) {
          if (
            bound[0] < bounds[roundedBottom][i][1] &&
            bound[1] > bounds[roundedBottom][i][0]
          ) {
            hasCollision = true;
            // Effectively a break from the each loop
            return false;
          }
        }
        bounds[roundedBottom].push(bound);
      }
      section.setAttribute('class', originalClass);
    });
    return hasCollision;
  }

  // These 3 functions match My.Hymnary's slides.js equivalents
  _applyRevealResolution () {
    const config = this.reveal.getConfig();
    this.width = config.width;
    this.height = config.height;
    const idx = this.resolutions.findIndex(
      (res) => res[0] === this.width && res[1] === this.height
    );
    this.resolutionIdx = idx !== -1 ? idx : this.resolutionIdx;
  }
  _shrink () {
    this._applyRevealResolution();
    if (this.resolutionIdx < this.resolutions.length - 1) {
      this.resolutionIdx++;
      this.width = this.resolutions[this.resolutionIdx][0];
      this.height = this.resolutions[this.resolutionIdx][1];
      this.reveal.configure({ width: this.width, height: this.height });
      jQuery('#loading-spinner').show();
    }
  }
  _expand () {
    this._applyRevealResolution();
    if (this.resolutionIdx > 0) {
      this.resolutionIdx--;
      this.width = this.resolutions[this.resolutionIdx][0];
      this.height = this.resolutions[this.resolutionIdx][1];
      this.reveal.configure({ width: this.width, height: this.height });
      jQuery('#loading-spinner').show();
    }
  }

  _slidify (section, musicData, data) {
    if (!data) {
      return;
    }
    let i = this.toolkits.length;
    let toolkitName =
      JSON.parse(section.getAttribute('data-musicxml-toolkit') || '{}')
        .toolkit || null;
    let ToolkitType = this.ToolkitType;
    if (toolkitName && window[toolkitName]) {
      ToolkitType = window[toolkitName];
    }
    this.toolkits[i] = new ToolkitType();
    let toolkit = this.toolkits[i];
    section.setAttribute('id', `RevealMusicXML${i}`);
    if (typeof toolkit.setMusicData !== 'undefined') {
      toolkit.setMusicData(musicData);
    }
    toolkit.loadData(data, musicData);
    this._setOptions(toolkit);
    this.translationCounts[i] = toolkit.numVerses - 1;
    this.staveCounts[i] = toolkit.numStaves;
    this._render(section, toolkit, i);
    // TODO: Possibly use Reveal's 'resize' event when it works with percentage sizes
    // (https://github.com/hakimel/reveal.js/issues/2411).
    window.addEventListener('resize', () => {
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => {
        this._reslidify();
        jQuery('#loading-spinner').hide();
      }, 100);
    });
    // Zoom out if there are any collisions between lyric elements
    // TODO: Could we zoom out again if there are still collisions after the first?
    if (this._getHasCollisions()) {
      this._shrink();
    } else {
      jQuery('#loading-spinner').hide();
    }
    jQuery('#loading-spinner').hide();
  }

  _adjustMEI (meiStr, tkIdx) {
    try {
      // See https://www.w3schools.com/xml/xml_parser.asp
      const parser = new window.DOMParser();
      // See https://stackoverflow.com/a/35917295
      const serializer = new window.XMLSerializer();
      let meiDoc = parser.parseFromString(meiStr, 'text/xml');

      // Shrink the footer and italicize text marked with ***
      let pgFoot = meiDoc.getElementsByTagName('pgFoot')[0];
      if (pgFoot) {
        let rends = pgFoot.children;
        for (let i = 0; i < rends.length; i++) {
          let rend = rends[i];
          rend.setAttribute('fontsize', '200pt');
          // Use innerHTML not textContent because otherwise the tags are treated like text
          rend.innerHTML = rend.innerHTML.replaceAll(
            /\*\*\*(.*?)\*\*\*/g,
            '<rend fontstyle="italic">$1</rend>'
          );
          if (rend.innerHTML.indexOf('***') !== -1) {
            rend.innerHTML =
              rend.innerHTML.replace('***', '<rend fontstyle="italic">') +
              '</rend>';
          }
        }
      }

      // Remove all tempo markings
      let tempos = meiDoc.getElementsByTagName('tempo');
      for (let i = 0; i < tempos.length; i++) {
        tempos[i].innerHTML = '';
      }

      // Manually increase space between staves (if there are multiple staves)
      // If spacing is changed, changes to lyricsOffset and spacingSystem in _setOptions may be required
      let staffDefs = meiDoc.getElementsByTagName('staffDef');
      if (staffDefs.length > 1) {
        staffDefs[1].setAttribute(
          'spacing',
          this.baseStaffDefSpacing +
            this.additionalStaffDefSpacing +
            (this.translationUnitDiff +
              this.additionalTranslationStaffDefSpacing) *
              this.translationCounts[tkIdx]
        );
      }

      // Remove measure numbers
      let scoreDef = meiDoc.getElementsByTagName('scoreDef')[0];
      scoreDef.setAttribute('mnum.visible', 'false');

      // Remove section labels
      let labels = meiDoc.getElementsByTagName('rend');
      for (let i = 0; i < labels.length; i++) {
        if (labels[i].parentElement.nodeName === 'dir') {
          labels[i].innerHTML = '';
        }
      }

      // Copy doubled system breaks to after the next measure
      // TODO: Remove this once https://github.com/rism-digital/verovio/issues/3423 is fixed
      let measures = meiDoc.querySelectorAll('sb + sb + measure + measure');
      for (let i = 0; i < measures.length; i++) {
        let measure = measures[i];
        let sb =
          measure.previousElementSibling.previousElementSibling.cloneNode();
        measure.parentNode.insertBefore(sb, measure);
      }

      meiStr = serializer.serializeToString(meiDoc);
    } catch (error) {
      console.log('MEI adjustment failed');
    }
    return meiStr;
  }

  _adjustSVG (svgStr, tkIdx, unit, lyricSize) {
    try {
      // See https://www.w3schools.com/xml/xml_parser.asp
      const parser = new window.DOMParser();
      // See https://stackoverflow.com/a/35917295
      const serializer = new window.XMLSerializer();
      let svgDoc = parser.parseFromString(svgStr, 'image/svg+xml');

      // Make the font size of lyrics consistent
      const fontSize = lyricSize * unit * 10;
      let syls = svgDoc.querySelectorAll(
        `g.syl text tspan tspan:not([font-size="${fontSize}px"])`
      );
      for (let i = 0; i < syls.length; i++) {
        let syl = syls[i];
        syl.setAttribute('font-size', fontSize + 'px');
      }
      let svg = svgDoc.querySelector(`svg`);
      svg.setAttribute('height', this.height + 'px');

      // Adjust the height of lyrics to look centered (despite the spacingStaff)
      let lyrics = svgDoc.querySelectorAll(
        `g.verse g.syl text[y], g.verse g.syl rect[y]`
      );
      for (let i = 0; i < lyrics.length; i++) {
        let lyric = lyrics[i];
        let verse = lyric.parentElement.parentElement;
        lyric.setAttribute(
          'y',
          parseInt(lyric.getAttribute('y')) +
            (this.staveCounts[tkIdx] > 1 ? this.lyricsOffset : -400) +
            parseInt(verse.getAttribute('data-n')) * this.translationOffset
        );
      }

      // Get every g.syl which is the second in a g.verse (generally occurs after elisions)
      //  and place its content within the first g.syl in that g.verse
      //  (this prevents a large space between the elision and the second syllable it's attached to)
      let secondSyls = svgDoc.querySelectorAll(`g.verse g.syl:nth-child(2)`);
      for (let i = 0; i < secondSyls.length; i++) {
        let secondSyl = secondSyls[i];
        let tspans = secondSyl.querySelectorAll(`text tspan`);
        let others = secondSyl.querySelectorAll(`:not(text, tspan)`);

        let verse = secondSyl.parentElement;
        let firstSyl = verse.querySelector(`g.verse g.syl:nth-child(1)`);
        if (firstSyl) {
          let text = firstSyl.querySelector(`text`);
          if (text) {
            for (let j = 0; j < tspans.length; j++) {
              let tspan = tspans[j];
              text.appendChild(tspan);
            }
            for (let j = 0; j < others.length; j++) {
              let other = others[j];
              firstSyl.appendChild(other);
            }
            secondSyl.remove();
          }
        }
      }

      let flags = svgDoc.querySelectorAll(`g.flag use`);
      for (let i = 0; i < flags.length; i++) {
        let flag = flags[i];
        let width = parseInt(flag.getAttribute('width')) * this.flagSizeScaling;
        let height =
          parseInt(flag.getAttribute('height')) * this.flagSizeScaling;
        flag.setAttribute('width', width + 'px');
        flag.setAttribute('height', height + 'px');
      }

      svgStr = serializer.serializeToString(svgDoc);
    } catch (error) {
      console.log('SVG adjustment failed');
    }
    return svgStr;
  }
}
